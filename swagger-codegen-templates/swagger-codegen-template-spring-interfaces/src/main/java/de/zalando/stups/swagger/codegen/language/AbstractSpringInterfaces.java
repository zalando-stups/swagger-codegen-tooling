/**
 * Copyright (C) 2015 Zalando SE (http://tech.zalando.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.zalando.stups.swagger.codegen.language;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.zalando.stups.swagger.codegen.ConfigurableCodegenConfig;

import com.google.common.collect.Lists;

import io.swagger.codegen.CodegenConfig;
import io.swagger.codegen.CodegenModel;
import io.swagger.codegen.CodegenOperation;
import io.swagger.codegen.CodegenProperty;
import io.swagger.codegen.CodegenResponse;
import io.swagger.codegen.CodegenType;
import io.swagger.codegen.SupportingFile;
import io.swagger.codegen.languages.JavaClientCodegen;
import io.swagger.models.Operation;
import io.swagger.models.Swagger;

/**
 * https://github.com/swagger-api/swagger-codegen/blob/master/modules/swagger-codegen/src/main/java/com/wordnik/swagger/codegen/languages/JaxRSServerCodegen.java.
 *
 * @author jbellmann
 */
public class AbstractSpringInterfaces extends JavaClientCodegen implements CodegenConfig, ConfigurableCodegenConfig {

    protected String sourceFolder = "";

    private boolean skipApiGeneration = false;

    private boolean skipModelGeneration = false;

    private String apiPrefix = "";

    @Override
    public void setApiPrefix(String apiPrefix) {
        this.apiPrefix = apiPrefix;
    }

    @Override
    public void skipApiGeneration() {
        skipApiGeneration = true;
    }

    @Override
    public void skipModelGeneration() {
        skipModelGeneration = true;
    }

    @Override
    public CodegenType getTag() {
        return CodegenType.SERVER;
    }

    @Override
    public String getName() {
        return "springinterfaces";
    }

    @Override
    public void preprocessSwagger(Swagger swagger) {
        vendorExtensions.put("basePath", swagger.getBasePath());
        super.preprocessSwagger(swagger);
    }

    @Override
    public String getHelp() {
        return "Generates Spring-Interfaces.";
    }

    public AbstractSpringInterfaces() {
        super();
        embeddedTemplateDir = templateDir = "SpringInterfaces";
        modelTemplateFiles.put("model.mustache", ".java");
        apiTemplateFiles.put("api.mustache", ".java");
    }

    @Override
    public List<SupportingFile> supportingFiles() {
        supportingFiles.clear();

        languageSpecificPrimitives = new HashSet<String>(
                Arrays.asList("String", "boolean", "Boolean", "Double", "Integer", "Long", "Float"));

        return supportingFiles;
    }

    @Override
    public String apiFileFolder() {
        return outputFolder + "/" + apiPackage().replace('.', File.separatorChar);
    }

    @Override
    public String modelFileFolder() {
        return outputFolder + "/" + modelPackage().replace('.', File.separatorChar);
    }

    @Override
    public String modelPackage() {
        if (skipModelGeneration) {
            return "MODEL_SKIPPED";
        }

        if (this.modelPackage == null || this.modelPackage.trim().isEmpty()) {
            throw new RuntimeException("'modelPackage' should not be null or empty");
        }

        return this.modelPackage;
    }

    @Override
    public String apiPackage() {
        if (skipApiGeneration) {
            return "API_SKIPPED";
        }

        if (this.apiPackage == null || this.apiPackage.trim().isEmpty()) {
            throw new RuntimeException("'apiPackage' should not be null or empty");
        }

        return this.apiPackage;
    }

    @Override
    public void addOperationToGroup(final String tag, final String resourcePath, final Operation operation,
            final CodegenOperation co, final Map<String, List<CodegenOperation>> operations) {
        String basePath = resourcePath;
        if (basePath.startsWith("/")) {
            basePath = basePath.substring(1);
        }

        int pos = basePath.indexOf("/");
        if (pos > 0) {
            basePath = basePath.substring(0, pos);
        }

        if (basePath == "") {
            basePath = "default";
        } else {
            if (co.path.startsWith("/" + basePath)) {
                co.path = co.path.substring(("/" + basePath).length());
            }

            co.subresourceOperation = !co.path.isEmpty();
        }

        List<CodegenOperation> opList = operations.get(basePath);
        if (opList == null) {
            opList = new ArrayList<CodegenOperation>();
            operations.put(basePath, opList);
        }

        opList.add(co);
        co.baseName = basePath;
    }

    @Override
    public void processOpts() {
        super.processOpts();
        // we do not want to have
        importMapping.remove("SerializedName");
    }

    @Override
    public void postProcessModelProperty(CodegenModel model, CodegenProperty property) {
        super.postProcessModelProperty(model, property);
        model.imports.remove("SerializedName");
    }

    private final List<String> methodsWithoutRequestBody = Lists.newArrayList("GET", "DELETE");

    @Override
    public Map<String, Object> postProcessOperations(Map<String, Object> objs) {
        Map<String, Object> operations = (Map<String, Object>) objs.get("operations");
        if (operations != null) {
            List<CodegenOperation> ops = (List<CodegenOperation>) operations.get("operation");
            for (CodegenOperation operation : ops) {
                if (methodsWithoutRequestBody.contains(operation.httpMethod)) {
                    operation.vendorExtensions.put("consumesExpected", false);
                } else {
                    operation.vendorExtensions.put("consumesExpected", true);
                }

                List<CodegenResponse> responses = operation.responses;
                if (responses != null) {
                    for (CodegenResponse resp : responses) {
                        if ("0".equals(resp.code)) {
                            resp.code = "200";
                        }
                    }
                }
                System.out.println(operation.operationId);
                io.swagger.util.Json.prettyPrint(operation);

                if (operation.returnType == null) {
                    operation.returnType = getVoidReturnType();
                    operation.hasProduces = Boolean.FALSE;
                } else if (operation.returnType.startsWith("List")) {
                    String rt = operation.returnType;
                    int end = rt.lastIndexOf(">");
                    if (end > 0) {
                        operation.returnType = rt.substring("List<".length(), end).trim();
                        operation.returnContainer = "List";
                    }
                } else if (operation.returnType.startsWith("Map")) {
                    String rt = operation.returnType;
                    int end = rt.lastIndexOf(">");
                    if (end > 0) {
                        operation.returnType = rt.substring("Map<".length(), end).split(",")[1].trim();
                        operation.returnContainer = "Map";
                    }
                } else if (operation.returnType.startsWith("Set")) {
                    String rt = operation.returnType;
                    int end = rt.lastIndexOf(">");
                    if (end > 0) {
                        operation.returnType = rt.substring("Set<".length(), end).trim();
                        operation.returnContainer = "Set";
                    }
                }
            }
        }
        return objs;
    }

    protected String getVoidReturnType() {
        return "void";
    }

    @Override
    public void setApiPackage(final String apiPackage) {
        this.apiPackage = apiPackage;
    }

    @Override
    public void setModelPackage(final String modelPackage) {
        this.modelPackage = modelPackage;
    }

    @Override
    public boolean is303Supported() {
        return false;
    }

    @Override
    public void enable303() {
    }

    @Override
    public boolean isBuilderSupported() {
        return false;
    }

    @Override
    public void enableBuilderSupport() {
    }

    @Override
    public String toApiName(String name) {
        if (name.length() == 0) {
            return "DefaultApi";
        }

        name = sanitizeName(name);
        return apiPrefix + camelize(name) + "Api";
    }
}
